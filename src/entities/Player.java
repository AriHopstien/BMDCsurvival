package entities;

import engine.InputManager;
import hud.PhoneMessage;
import ui.Screen;

import javax.imageio.ImageIO;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.List;

public class Player extends MovableEntity {

    // מאפיינים ייחודיים לשחקן בלבד
    private boolean phoneOpen = false;
    private List<PhoneMessage> phoneMessages;
    private int unreadCount = 0;

    public Player(float x, float y) {
        // קריאה לבנאי של MovableEntity עם גודל 64x64
        super(x, y, 64, 64);

        this.phoneMessages = new ArrayList<>();
        this.speed = 350.0f;
        this.animationSpeed = 10; // הגדרת מהירות האנימציה שירשנו

        loadAnimations();
    }

    private void loadAnimations() {
        try {
            // טעינת הקבצים המקוריים שלך
            BufferedImage frontSheet = ImageIO.read(getClass().getResourceAsStream("/entities/player-front.png"));
            BufferedImage backSheet  = ImageIO.read(getClass().getResourceAsStream("/entities/player-back.png"));
            BufferedImage sideSheet  = ImageIO.read(getClass().getResourceAsStream("/entities/player-side.png"));

            // השמה למערכים שירשנו מ-MovableEntity
            walkDown = new BufferedImage[] {
                    frontSheet.getSubimage(0, 64, 64, 64),
                    frontSheet.getSubimage(0, 128, 64, 64)
            };

            walkUp = new BufferedImage[] {
                    backSheet.getSubimage(0, 0, 64, 64),
                    backSheet.getSubimage(0, 64, 64, 64)
            };

            walkRight = new BufferedImage[] {
                    sideSheet.getSubimage(0, 0, 64, 64),
                    sideSheet.getSubimage(64, 0, 64, 64)
            };

            walkLeft = new BufferedImage[] {
                    sideSheet.getSubimage(0, 64, 64, 64),
                    sideSheet.getSubimage(64, 64, 64, 64)
            };

            // קביעת ה-sprite ההתחלתי
            this.sprite = walkDown[0];

        } catch (Exception e) {
            System.out.println("Error loading player sprites: " + e.getMessage());
        }
    }

    public void update(InputManager input, Screen currentScreen) {
        if (!phoneOpen) {
            handleMovement(input);
            // שים לב: בתוך ה-GameWorld תקרא ל-player.move(deltaTime).
            // ה-move יקרא אוטומטית ל-updateAnimation() שירשנו.
        }

        // לוגיקת טלפון
        if (input.ENTER_key && currentScreen.canPressEnter()) {
            togglePhone();
            currentScreen.resetEnterTimer();
        }
    }

    private void handleMovement(InputManager input) {
        this.dx = 0;
        this.dy = 0;
        if (input.W_key) dy = -1;
        if (input.S_Key) dy = 1;
        if (input.A_key) dx = -1;
        if (input.D_key) dx = 1;
    }

    // --- מערכת הודעות וטלפון (ללא שינוי לוגי) ---
    public void togglePhone() {
        phoneOpen = !phoneOpen;
        if (phoneOpen) {
            stop(); // הפעולה שירשנו מ-MovableEntity שמאפסת dx ו-dy
        }
        if (phoneOpen && unreadCount > 0) unreadCount--;
    }

    public void addMessage(String sender, String text) {
        phoneMessages.add(new PhoneMessage(sender, text));
        if (!phoneOpen) unreadCount++;
    }

    public boolean isPhoneOpen() { return phoneOpen; }
    public List<PhoneMessage> getPhoneMessages() { return phoneMessages; }
    public int getUnreadCount() { return unreadCount; }

    // הסרנו את Render כי super.Render(g) ב-Entity עושה בדיוק את אותה עבודה
}